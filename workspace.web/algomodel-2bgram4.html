<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced N-Gram Autocomplete (AM2BG 2.0)</title>
  <style>
    :root {
      --primary: #4a6fa5;
      --secondary: #6c757d;
      --success: #28a745;
      --light: #f8f9fa;
      --dark: #343a40;
      --border: #ced4da;
      --shadow: rgba(0,0,0,0.1);
      --bg-gradient: linear-gradient(120deg, #f6f8fb, #edf1f7);
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: var(--bg-gradient);
      min-height: 100vh;
      color: var(--dark);
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 16px var(--shadow);
    }
    
    h1 {
      text-align: center;
      color: var(--primary);
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .subtitle {
      text-align: center;
      color: var(--secondary);
      margin-bottom: 30px;
      font-size: 1rem;
    }
    
    .text-area-container {
      position: relative;
      margin-bottom: 20px;
    }
    
    textarea {
      width: 100%;
      padding: 15px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 16px;
      line-height: 1.5;
      resize: vertical;
      min-height: 150px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      box-sizing: border-box;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(74, 111, 165, 0.25);
    }
    
    .suggestion-box {
      position: absolute;
      background: white;
      border: 1px solid var(--border);
      font-size: 14px;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--shadow);
      display: none;
      z-index: 9999;
      max-width: 300px;
      overflow: hidden;
      transition: opacity 0.2s;
    }
    
    .suggestion-item {
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.15s;
    }
    
    .suggestion-item:hover {
      background-color: #f0f4f8;
    }
    
    .suggestion-item.selected {
      background-color: #e8f0fe;
      font-weight: 500;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .settings-panel {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid #e9ecef;
    }
    
    .settings-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: var(--primary);
    }
    
    .settings-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    label {
      margin-right: 10px;
      font-size: 14px;
    }
    
    button, select, input[type="number"] {
      background: white;
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      color: var(--dark);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:hover {
      background-color: #f0f4f8;
      border-color: #c1c9d6;
    }
    
    button.primary {
      background-color: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    
    button.primary:hover {
      background-color: #3d5d8a;
      border-color: #3d5d8a;
    }
    
    button.info {
      background-color: #17a2b8;
      color: white;
      border-color: #17a2b8;
    }
    
    button.info:hover {
      background-color: #138496;
      border-color: #138496;
    }
    
    .btn-icon {
      margin-right: 6px;
    }
    
    .corpus-display {
      margin-top: 20px;
      border-top: 1px solid #eee;
      padding-top: 20px;
    }
    
    .status-message {
      background-color: #e8f4ff;
      border-left: 4px solid var(--primary);
      padding: 10px 15px;
      margin: 20px 0;
      font-size: 14px;
      color: #2c5282;
      border-radius: 0 4px 4px 0;
    }
    
    .shortcut-hint {
      margin-top: 10px;
      background: #fdfcef;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      color: #856404;
      border: 1px solid #fff3cd;
    }
    
    .shortcut-key {
      background: #eee;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      font-weight: 600;
      box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }
    
    .metrics-panel {
      display: flex;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      margin-bottom: 20px;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: space-between;
      border: 1px solid #e9ecef;
    }
    
    .metric-box {
      flex: 1 1 120px;
      text-align: center;
      padding: 12px;
      background: white;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .metric-title {
      font-size: 12px;
      color: var(--secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      font-weight: 600;
    }
    
    .metric-value {
      font-size: 22px;
      font-weight: 700;
      color: var(--primary);
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 24px;
      margin-left: 10px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .3s;
      border-radius: 24px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .3s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: var(--primary);
    }
    
    input:checked + .slider:before {
      transform: translateX(22px);
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
      margin-left: 6px;
      cursor: help;
    }
    
    .tooltip .tooltip-icon {
      background: #e9ecef;
      color: #6c757d;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      font-weight: normal;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    .footer {
      text-align: center;
      margin-top: 30px;
      font-size: 12px;
      color: var(--secondary);
    }

    @media (max-width: 600px) {
      .controls {
        flex-direction: column;
      }
      
      .settings-row {
        flex-direction: column;
        align-items: flex-start;
      }
      
      label {
        margin-bottom: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>AlgoModel 2BGram 4 (AM2BG 2.0)</h1>
    <p class="subtitle">Enhanced N-Gram Autocomplete Model with Adaptive Learning</p>
    
    <div class="settings-panel">
      <div class="settings-title">Model Configuration</div>
      <div class="settings-row">
        <label for="nGramSize">N-Gram Size:</label>
        <select id="nGramSize">
          <option value="2">2-Gram (Bigram)</option>
          <option value="3">3-Gram (Trigram)</option>
          <option value="4">4-Gram (Four-gram)</option>
          <option value="5">5-Gram (Five-gram)</option>
        </select>
        <div class="tooltip">
          <span class="tooltip-icon">?</span>
          <span class="tooltip-text">Determines how many previous words to consider when predicting the next word.</span>
        </div>
      </div>
      
      <div class="settings-row">
        <label for="maxSuggestions">Max Suggestions:</label>
        <input type="number" id="maxSuggestions" min="1" max="10" value="3">
        <div class="tooltip">
          <span class="tooltip-icon">?</span>
          <span class="tooltip-text">Maximum number of suggestions to show at once.</span>
        </div>
      </div>
      
      <div class="settings-row">
        <label>Learning Mode:</label>
        <label class="toggle-switch">
          <input type="checkbox" id="learningMode" checked>
          <span class="slider"></span>
        </label>
        <div class="tooltip">
          <span class="tooltip-icon">?</span>
          <span class="tooltip-text">When enabled, the model learns from your writing to improve suggestions.</span>
        </div>
      </div>
      
      <div class="settings-row">
        <label>Context-aware Mode:</label>
        <label class="toggle-switch">
          <input type="checkbox" id="contextAwareMode" checked>
          <span class="slider"></span>
        </label>
        <div class="tooltip">
          <span class="tooltip-icon">?</span>
          <span class="tooltip-text">Considers entire document context for more relevant suggestions.</span>
        </div>
      </div>
    </div>
    
    <div class="text-area-container">
      <textarea id="myText" rows="8" placeholder="Start typing here... (Press Tab to accept suggestions)"></textarea>
      <div id="suggestionBox" class="suggestion-box"></div>
    </div>
    
    <div class="shortcut-hint">
      <strong>Keyboard Shortcuts:</strong> 
      Press <span class="shortcut-key">Tab</span> to accept the selected suggestion, 
      <span class="shortcut-key">↑</span>/<span class="shortcut-key">↓</span> to navigate between suggestions.
    </div>
    
    <div class="controls">
      <button id="saveButton" class="primary">
        <span class="btn-icon">💾</span> Save Model
      </button>
      <button id="exportButton">
        <span class="btn-icon">📤</span> Export Data
      </button>
      <button id="importButton">
        <span class="btn-icon">📥</span> Import Data
      </button>
      <button id="clearButton">
        <span class="btn-icon">🗑️</span> Clear Model
      </button>
      <button id="analyzeButton" class="info">
        <span class="btn-icon">📊</span> Analyze Text
      </button>
    </div>
    
    <div class="metrics-panel">
      <div class="metric-box">
        <div class="metric-title">Total N-Grams</div>
        <div class="metric-value" id="totalNGrams">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-title">Vocabulary Size</div>
        <div class="metric-value" id="vocabSize">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-title">Suggestions</div>
        <div class="metric-value" id="suggestionCount">0</div>
      </div>
      <div class="metric-box">
        <div class="metric-title">Accepted</div>
        <div class="metric-value" id="acceptedCount">0</div>
      </div>
    </div>
    
    <div id="statusMessage" class="status-message" style="display:none;">
      Model updated successfully! Learning from your text patterns.
    </div>
    
    <input type="file" id="fileInput" style="display: none;">
    
    <div class="footer">
      AlgoModel 2BGram 4 (AM2BG 2.0) - Enhanced N-Gram Autocomplete Model &copy; 2025
    </div>
  </div>

  <script>
    class Ngram {
      constructor() {
        this.STORAGE_KEY = "AM2BG_ngramMemory";
        this.STATS_KEY = "AM2BG_statistics";
        this.MODEL_CONFIG_KEY = "AM2BG_config";
        
        // DOM Elements
        this.textArea = document.querySelector("#myText");
        this.suggestionBox = document.querySelector("#suggestionBox");
        this.nGramSizeSelect = document.querySelector("#nGramSize");
        this.maxSuggestionsInput = document.querySelector("#maxSuggestions");
        this.learningModeToggle = document.querySelector("#learningMode");
        this.contextAwareModeToggle = document.querySelector("#contextAwareMode");
        this.saveButton = document.querySelector("#saveButton");
        this.exportButton = document.querySelector("#exportButton");
        this.importButton = document.querySelector("#importButton");
        this.clearButton = document.querySelector("#clearButton");
        this.analyzeButton = document.querySelector("#analyzeButton");
        this.fileInput = document.querySelector("#fileInput");
        this.statusMessage = document.querySelector("#statusMessage");
        
        // Metrics elements
        this.totalNGramsEl = document.querySelector("#totalNGrams");
        this.vocabSizeEl = document.querySelector("#vocabSize");
        this.suggestionCountEl = document.querySelector("#suggestionCount");
        this.acceptedCountEl = document.querySelector("#acceptedCount");
        
        // Model data
        this.ngrams = this.loadFromStorage(this.STORAGE_KEY) || {};
        this.vocabulary = new Set();
        this.stats = this.loadFromStorage(this.STATS_KEY) || {
          suggestionCount: 0,
          acceptedCount: 0,
          modelSaves: 0,
          lastSave: null
        };
        
        // Configuration
        this.config = this.loadFromStorage(this.MODEL_CONFIG_KEY) || {
          nGramSize: 2,
          maxSuggestions: 3,
          learningMode: true,
          contextAwareMode: true
        };
        
        // Apply loaded config to UI
        this.nGramSizeSelect.value = this.config.nGramSize;
        this.maxSuggestionsInput.value = this.config.maxSuggestions;
        this.learningModeToggle.checked = this.config.learningMode;
        this.contextAwareModeToggle.checked = this.config.contextAwareMode;
        
        // Runtime variables
        this.currentSuggestions = [];
        this.selectedIndex = 0;
        this.updateMetrics();
        
        // Initialize event listeners
        this.initEventListeners();
      }
      
      initEventListeners() {
        // Text input events
        this.textArea.addEventListener("input", this.handleTextInput.bind(this));
        this.textArea.addEventListener("keydown", this.handleKeyDown.bind(this));
        this.textArea.addEventListener("blur", this.handleBlur.bind(this));
        
        // Configuration changes
        this.nGramSizeSelect.addEventListener("change", this.updateConfig.bind(this));
        this.maxSuggestionsInput.addEventListener("change", this.updateConfig.bind(this));
        this.learningModeToggle.addEventListener("change", this.updateConfig.bind(this));
        this.contextAwareModeToggle.addEventListener("change", this.updateConfig.bind(this));
        
        // Button actions
        this.saveButton.addEventListener("click", this.saveModel.bind(this));
        this.exportButton.addEventListener("click", this.exportData.bind(this));
        this.importButton.addEventListener("click", () => this.fileInput.click());
        this.clearButton.addEventListener("click", this.clearModel.bind(this));
        this.analyzeButton.addEventListener("click", this.analyzeText.bind(this));
        this.fileInput.addEventListener("change", this.importData.bind(this));
        
        // Suggestion box click events
        this.suggestionBox.addEventListener("click", this.handleSuggestionClick.bind(this));
      }
      
      loadFromStorage(key) {
        try {
          const stored = localStorage.getItem(key);
          return stored ? JSON.parse(stored) : null;
        } catch (e) {
          console.error("Error loading from storage:", e);
          return null;
        }
      }
      
      saveToStorage(key, data) {
        try {
          localStorage.setItem(key, JSON.stringify(data));
          return true;
        } catch (e) {
          console.error("Error saving to storage:", e);
          this.showStatus("Error saving model: Storage quota might be exceeded", "error");
          return false;
        }
      }
      
      updateConfig() {
        this.config.nGramSize = parseInt(this.nGramSizeSelect.value, 10);
        this.config.maxSuggestions = parseInt(this.maxSuggestionsInput.value, 10);
        this.config.learningMode = this.learningModeToggle.checked;
        this.config.contextAwareMode = this.contextAwareModeToggle.checked;
        
        this.saveToStorage(this.MODEL_CONFIG_KEY, this.config);
        this.hideSuggestions();
        this.showStatus("Configuration updated");
      }
      
      getNGram(text, n = null) {
        const nGramSize = n || this.config.nGramSize;
        const words = text.trim().split(/\s+/);
        if (words.length >= nGramSize) {
          return words.slice(-nGramSize).join(" ");
        }
        return null;
      }
      
      handleTextInput() {
        const cursorPosition = this.textArea.selectionStart;
        const text = this.textArea.value.substring(0, cursorPosition);
        
        // Check if text ends with a space (user completed a word)
        if (text.endsWith(" ")) {
          const lastNGram = this.getNGram(text);
          
          if (lastNGram) {
            this.generateSuggestions(lastNGram);
          } else {
            this.hideSuggestions();
          }
        } else {
          this.hideSuggestions();
        }
      }
      
      generateSuggestions(nGram) {
        if (!nGram) {
          this.hideSuggestions();
          return;
        }
        
        let suggestions = [];
        
        // Get suggestions from the model
        if (this.ngrams[nGram]) {
          // Sort suggestions by frequency (most frequent first)
          suggestions = [...this.ngrams[nGram]];
          suggestions.sort((a, b) => b.count - a.count);
          suggestions = suggestions.slice(0, this.config.maxSuggestions);
        }
        
        if (suggestions.length === 0) {
          this.hideSuggestions();
          return;
        }
        
        this.showSuggestions(suggestions);
        this.stats.suggestionCount++;
        this.updateMetrics();
      }
      
      showSuggestions(suggestions) {
        this.currentSuggestions = suggestions;
        this.selectedIndex = 0;
        
        this.suggestionBox.innerHTML = "";
        suggestions.forEach((suggestion, index) => {
          const item = document.createElement("div");
          item.className = "suggestion-item" + (index === 0 ? " selected" : "");
          item.dataset.index = index;
          item.textContent = suggestion.word;
          this.suggestionBox.appendChild(item);
        });
        
        const rect = this.textArea.getBoundingClientRect();
        const cursorPosition = this.getCursorCoordinates();
        
        this.suggestionBox.style.left = `${cursorPosition.left}px`;
        this.suggestionBox.style.top = `${cursorPosition.top + 20}px`;
        this.suggestionBox.style.display = "block";
      }
      
      getCursorCoordinates() {
        // Create a mirror div to calculate the exact cursor position
        const div = document.createElement('div');
        const style = getComputedStyle(this.textArea);
        
        // Copy styles from textarea
        [
          'fontFamily', 'fontSize', 'fontWeight', 'lineHeight',
          'letterSpacing', 'padding', 'border', 'boxSizing'
        ].forEach(prop => {
          div.style[prop] = style[prop];
        });
        
        // Set content and styles for measuring
        div.style.position = 'absolute';
        div.style.whiteSpace = 'pre-wrap';
        div.style.wordWrap = 'break-word';
        div.style.visibility = 'hidden';
        div.style.width = `${this.textArea.offsetWidth}px`;
        
        // Get text up to cursor
        const text = this.textArea.value.substring(0, this.textArea.selectionStart);
        div.textContent = text;
        
        // Add a span at cursor position
        const span = document.createElement('span');
        span.textContent = '.';
        div.appendChild(span);
        
        document.body.appendChild(div);
        const coordinates = {
          top: span.offsetTop + this.textArea.getBoundingClientRect().top + window.scrollY,
          left: span.offsetLeft + this.textArea.getBoundingClientRect().left
        };
        
        document.body.removeChild(div);
        return coordinates;
      }
      
      hideSuggestions() {
        this.suggestionBox.style.display = "none";
        this.currentSuggestions = [];
      }
      
      handleKeyDown(e) {
        // Tab key to accept suggestion
        if (e.key === "Tab" && this.suggestionBox.style.display === "block") {
          e.preventDefault();
          this.acceptSuggestion(this.selectedIndex);
        }
        
        // Up/Down arrows to navigate suggestions
        if ((e.key === "ArrowUp" || e.key === "ArrowDown") && 
            this.suggestionBox.style.display === "block" && 
            this.currentSuggestions.length > 1) {
          e.preventDefault();
          
          const items = this.suggestionBox.querySelectorAll(".suggestion-item");
          items[this.selectedIndex].classList.remove("selected");
          
          if (e.key === "ArrowUp") {
            this.selectedIndex = (this.selectedIndex - 1 + this.currentSuggestions.length) % this.currentSuggestions.length;
          } else {
            this.selectedIndex = (this.selectedIndex + 1) % this.currentSuggestions.length;
          }
          
          items[this.selectedIndex].classList.add("selected");
        }
        
        // Escape key to hide suggestions
        if (e.key === "Escape" && this.suggestionBox.style.display === "block") {
          this.hideSuggestions();
        }
      }
      
      handleSuggestionClick(e) {
        const item = e.target.closest(".suggestion-item");
        if (item) {
          const index = parseInt(item.dataset.index, 10);
          this.acceptSuggestion(index);
        }
      }
      
      acceptSuggestion(index) {
        if (!this.currentSuggestions[index]) return;
        
        const suggestion = this.currentSuggestions[index].word;
        const cursorPos = this.textArea.selectionStart;
        
        // Insert the suggestion at cursor position
        this.textArea.value = 
          this.textArea.value.substring(0, cursorPos) + 
          suggestion + " " + 
          this.textArea.value.substring(cursorPos);
        
        // Move cursor after the inserted suggestion
        this.textArea.selectionStart = this.textArea.selectionEnd = cursorPos + suggestion.length + 1;
        
        this.hideSuggestions();
        this.stats.acceptedCount++;
        this.updateMetrics();
        
        // Focus back on the textarea
        this.textArea.focus();
      }
      
      handleBlur() {
        // Don't hide suggestions immediately to allow clicking on them
        setTimeout(() => {
          if (!this.suggestionBox.contains(document.activeElement)) {
            this.hideSuggestions();
          }
        }, 200);
        
        // Learn from the current text if learning mode is enabled
        if (this.config.learningMode) {
          this.learnFromText(this.textArea.value);
        }
      }
      
      learnFromText(text) {
        if (!text.trim()) return;
        
        const words = text.trim().split(/\s+/);
        
        // Extract unique words for vocabulary
        words.forEach(word => this.vocabulary.add(word.toLowerCase()));
        
        // Build n-grams of different sizes for better model performance
        for (let n = 2; n <= Math.min(5, this.config.nGramSize + 1); n++) {
          for (let i = 0; i < words.length - n; i++) {
            const key = words.slice(i, i + n - 1).join(" ");
            const nextWord = words[i + n - 1];
            
            if (!this.ngrams[key]) {
              this.ngrams[key] = [];
            }
            
            // Check if this word already exists in the list
            const existingEntry = this.ngrams[key].find(entry => entry.word === nextWord);
            
            if (existingEntry) {
              existingEntry.count++;
            } else {
              this.ngrams[key].push({ word: nextWord, count: 1 });
            }
          }
        }
        
        // Context-aware processing if enabled
        if (this.config.contextAwareMode) {
          // Analyze document level context for improved predictions
          this.analyzeContextPatterns(words);
        }
        
        this.updateMetrics();
      }
      
      analyzeContextPatterns(words) {
        // This method would implement more advanced context analysis
        // For now, we'll build longer n-grams for document context
        const maxContextSize = Math.min(7, words.length);
        
        for (let n = this.config.nGramSize + 1; n <= maxContextSize; n++) {
          for (let i = 0; i < words.length - n; i++) {
            // Only store these larger contexts if they appear multiple times
            const prefix = words.slice(i, i + n - 1).join(" ");
            const suffix = words[i + n - 1];
            
            // Check if this prefix appears elsewhere in the text
            let occurrences = 0;
            for (let j = 0; j < words.length - n + 1; j++) {
              if (i !== j && words.slice(j, j + n - 1).join(" ") === prefix) {
                occurrences++;
              }
            }
            
            // If this context appears multiple times, store it with higher weight
            if (occurrences > 0) {
              if (!this.ngrams[prefix]) {
                this.ngrams[prefix] = [];
              }
              
              // Continuing from the analyzeContextPatterns method

              const existingEntry = this.ngrams[prefix].find(entry => entry.word === suffix);
              
              if (existingEntry) {
                existingEntry.count += occurrences;
              } else {
                this.ngrams[prefix].push({ word: suffix, count: occurrences });
              }
            }
          }
        }
      }
      
      saveModel() {
        // Save the model to localStorage
        if (this.saveToStorage(this.STORAGE_KEY, this.ngrams)) {
          // Update statistics
          this.stats.modelSaves++;
          this.stats.lastSave = new Date().toISOString();
          this.saveToStorage(this.STATS_KEY, this.stats);
          
          this.showStatus("Model saved successfully!");
        }
      }
      
      exportData() {
        const exportData = {
          ngrams: this.ngrams,
          vocabulary: Array.from(this.vocabulary),
          config: this.config,
          stats: this.stats,
          version: "AM2BG 2.0"
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement("a");
        a.href = url;
        a.download = `AM2BG_model_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.showStatus("Model exported successfully!");
      }
      
      importData(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            
            // Verify data structure
            if (!data.ngrams || !data.vocabulary) {
              throw new Error("Invalid model data format");
            }
            
            // Import data
            this.ngrams = data.ngrams;
            this.vocabulary = new Set(data.vocabulary);
            
            // Import config if available
            if (data.config) {
              this.config = data.config;
              this.nGramSizeSelect.value = this.config.nGramSize;
              this.maxSuggestionsInput.value = this.config.maxSuggestions;
              this.learningModeToggle.checked = this.config.learningMode;
              this.contextAwareModeToggle.checked = this.config.contextAwareMode;
            }
            
            // Import stats if available
            if (data.stats) {
              this.stats = data.stats;
            }
            
            this.saveToStorage(this.STORAGE_KEY, this.ngrams);
            this.saveToStorage(this.MODEL_CONFIG_KEY, this.config);
            this.saveToStorage(this.STATS_KEY, this.stats);
            
            this.updateMetrics();
            this.showStatus("Model imported successfully!");
          } catch (error) {
            console.error("Import error:", error);
            this.showStatus("Failed to import model: " + error.message, "error");
          }
          
          // Reset file input
          this.fileInput.value = "";
        };
        
        reader.readAsText(file);
      }
      
      clearModel() {
        // Confirm before clearing
        if (confirm("Are you sure you want to clear the model? All learned data will be lost.")) {
          this.ngrams = {};
          this.vocabulary = new Set();
          this.stats = {
            suggestionCount: 0,
            acceptedCount: 0,
            modelSaves: 0,
            lastSave: null
          };
          
          // Clear storage
          localStorage.removeItem(this.STORAGE_KEY);
          localStorage.removeItem(this.STATS_KEY);
          
          this.updateMetrics();
          this.showStatus("Model cleared successfully!");
        }
      }
      
      analyzeText() {
        const text = this.textArea.value;
        if (!text.trim()) {
          this.showStatus("Please enter some text to analyze", "error");
          return;
        }
        
        // Learn from the current text if not already done
        this.learnFromText(text);
        
        // Calculate text statistics
        const words = text.trim().split(/\s+/);
        const uniqueWords = new Set(words).size;
        const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;
        
        // Show analysis results
        let message = `Analysis Complete:\n`;
        message += `• Words: ${words.length}\n`;
        message += `• Unique Words: ${uniqueWords}\n`;
        message += `• Average Word Length: ${avgWordLength.toFixed(1)}\n`;
        message += `• N-Grams Added: ${Object.keys(this.ngrams).length}\n`;
        message += `• Most Common N-Gram: ${this.findMostCommonNGram()}`;
        
        alert(message);
      }
      
      findMostCommonNGram() {
        let maxCount = 0;
        let mostCommonNGram = "None";
        
        for (const [ngram, words] of Object.entries(this.ngrams)) {
          const totalCount = words.reduce((sum, entry) => sum + entry.count, 0);
          if (totalCount > maxCount) {
            maxCount = totalCount;
            mostCommonNGram = ngram;
          }
        }
        
        return `"${mostCommonNGram}" (${maxCount} occurrences)`;
      }
      
      updateMetrics() {
        // Count total n-grams
        let totalNGrams = 0;
        for (const key in this.ngrams) {
          totalNGrams += this.ngrams[key].length;
        }
        
        this.totalNGramsEl.textContent = totalNGrams;
        this.vocabSizeEl.textContent = this.vocabulary.size;
        this.suggestionCountEl.textContent = this.stats.suggestionCount;
        this.acceptedCountEl.textContent = this.stats.acceptedCount;
      }
      
      showStatus(message, type = "success") {
        this.statusMessage.textContent = message;
        this.statusMessage.style.display = "block";
        
        if (type === "error") {
          this.statusMessage.style.backgroundColor = "#ffebee";
          this.statusMessage.style.borderLeftColor = "#f44336";
          this.statusMessage.style.color = "#c62828";
        } else {
          this.statusMessage.style.backgroundColor = "#e8f4ff";
          this.statusMessage.style.borderLeftColor = "#4a6fa5";
          this.statusMessage.style.color = "#2c5282";
        }
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          this.statusMessage.style.display = "none";
        }, 5000);
      }
    }

    // Enhanced features for AM2BG 2.0
    class AM2BG extends Ngram {
      constructor() {
        super();
        
        // Additional advanced features
        this.adaptiveWeighting = true;
        this.recencyFactor = 0.2;
        this.semanticGrouping = new Map(); // For semantic relationship tracking
        
        // Initialize advanced metrics tracking
        this.advancedStats = {
          patternMatches: 0,
          semanticMatches: 0,
          adaptiveAdjustments: 0
        };
        
        this.initAdvancedFeatures();
      }
      
      initAdvancedFeatures() {
        // Override the generateSuggestions method to include advanced features
        const originalGenerateSuggestions = this.generateSuggestions.bind(this);
        
        this.generateSuggestions = (nGram) => {
          let suggestions = [];
          
          // Get base suggestions from the original method
          if (this.ngrams[nGram]) {
            suggestions = [...this.ngrams[nGram]];
          }
          
          // Apply adaptive weighting if enabled
          if (this.adaptiveWeighting && suggestions.length > 0) {
            suggestions = this.applyAdaptiveWeighting(suggestions, nGram);
          }
          
          // Apply semantic relationships if available
          const semanticSuggestions = this.getSemanticSuggestions(nGram);
          if (semanticSuggestions.length > 0) {
            // Merge and deduplicate suggestions
            suggestions = this.mergeSuggestions(suggestions, semanticSuggestions);
          }
          
          // Apply additional context-aware filtering when appropriate
          if (this.config.contextAwareMode) {
            suggestions = this.contextFilter(suggestions);
          }
          
          // Sort by weighted score and limit to max suggestions
          suggestions.sort((a, b) => b.score || b.count - (a.score || a.count));
          suggestions = suggestions.slice(0, this.config.maxSuggestions);
          
          if (suggestions.length === 0) {
            this.hideSuggestions();
            return;
          }
          
          this.showSuggestions(suggestions);
          this.stats.suggestionCount++;
          this.updateMetrics();
        };
      }
      
      applyAdaptiveWeighting(suggestions, nGram) {
        // Calculate recency and frequency weights
        const text = this.textArea.value;
        const recentContext = text.split(/\s+/).slice(-20).join(" ");
        
        return suggestions.map(s => {
          // Base score is the count
          let score = s.count;
          
          // Adjust for recency - boost words that appear in recent context
          if (recentContext.includes(s.word)) {
            score *= (1 + this.recencyFactor);
          }
          
          // Track adjustment for metrics
          this.advancedStats.adaptiveAdjustments++;
          
          return {
            ...s,
            score: score
          };
        });
      }
      
      getSemanticSuggestions(nGram) {
        // Get semantically related suggestions based on observed patterns
        let results = [];
        
        // Look for semantic relationships in our semantic grouping
        for (const [pattern, related] of this.semanticGrouping.entries()) {
          if (nGram.includes(pattern) || pattern.includes(nGram)) {
            // Found a semantically related pattern
            const semanticMatches = this.ngrams[related] || [];
            if (semanticMatches.length > 0) {
              results = results.concat(
                semanticMatches.map(m => ({
                  ...m,
                  // Lower weight for semantic matches
                  score: m.count * 0.7,
                  source: 'semantic'
                }))
              );
              this.advancedStats.semanticMatches++;
            }
          }
        }
        
        return results;
      }
      
      mergeSuggestions(baseSuggestions, additionalSuggestions) {
        // Create a map to eliminate duplicates while keeping highest score
        const merged = new Map();
        
        // Add all suggestions to the map
        [...baseSuggestions, ...additionalSuggestions].forEach(s => {
          const existing = merged.get(s.word);
          if (!existing || (s.score || s.count) > (existing.score || existing.count)) {
            merged.set(s.word, s);
          }
        });
        
        // Convert back to array
        return Array.from(merged.values());
      }
      
      contextFilter(suggestions) {
        // Apply additional filtering based on context
        const text = this.textArea.value;
        
        // Simple example: boost suggestions that match document tone/style
        const docStyle = this.determineDocumentStyle(text);
        
        return suggestions.map(s => {
          // If the suggestion matches document style, boost its score
          if (this.matchesDocumentStyle(s.word, docStyle)) {
            return {
              ...s,
              score: (s.score || s.count) * 1.2
            };
          }
          return s;
        });
      }
      
      determineDocumentStyle(text) {
        // Simple style detection - could be expanded
        const style = {
          formal: /therefore|moreover|consequently|however|nevertheless/gi.test(text),
          technical: /function|method|data|process|system/gi.test(text),
          casual: /hey|cool|awesome|gonna|wanna/gi.test(text)
        };
        
        // Determine dominant style
        return Object.entries(style)
          .sort((a, b) => b[1] - a[1])
          .map(x => x[0])[0] || 'neutral';
      }
      
      matchesDocumentStyle(word, style) {
        // Check if a word matches the detected document style
        const styleWords = {
          formal: ['therefore', 'furthermore', 'accordingly', 'consequently'],
          technical: ['function', 'process', 'method', 'system', 'data'],
          casual: ['great', 'nice', 'cool', 'awesome']
        };
        
        return styleWords[style]?.includes(word.toLowerCase()) || false;
      }
      
      // Override learnFromText to include semantic pattern learning
      learnFromText(text) {
        // Call the original method first
        super.learnFromText(text);
        
        // Additional semantic pattern learning
        this.learnSemanticPatterns(text);
      }
      
      learnSemanticPatterns(text) {
        // Find semantic relationships between words
        const words = text.trim().split(/\s+/);
        
        // Look for words that frequently appear in similar contexts
        for (let i = 0; i < words.length - 3; i++) {
          const currentPattern = words.slice(i, i + 2).join(" ");
          
          // Look for similar patterns elsewhere in the text
          for (let j = i + 2; j < words.length - 2; j++) {
            if (words[j+1] === words[i+1]) {
              // If words follow the same next word, they might be semantically related
              const relatedPattern = words.slice(j, j + 2).join(" ");
              
              // Store this relationship
              this.semanticGrouping.set(currentPattern, relatedPattern);
              this.semanticGrouping.set(relatedPattern, currentPattern);
            }
          }
        }
      }
    }

    // Initialize the advanced model when the DOM is fully loaded
    document.addEventListener("DOMContentLoaded", () => {
      window.model = new AM2BG();
    });
    </script>
</body>
</html>